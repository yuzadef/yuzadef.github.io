---
title: "Reflected XSS -> Cookie Tossing to steal money from unaware victims"
pubDate: "2025-12-5"
---
## Summary
Before anything, as usual, due to the program's policy, all target will be refered to as `target.com`. The target is a high-performance crypto perpetuals trading platform engineered by traders, optimized for trading. With the target's nature being a cryptocurrency platform, you will soon understand why the impact of this chained vulnerability could pose a critical security impact to it's users. A chained bug of Open Redirect, which escalated to Reflected XSS and leveraging the Cookie Tossing technique, an attacker could end up stealing money from unaware victims.

### Finding the Open Redirect
The target's in-scope includes the main application sitting on `www.target.com` as usual. Immediately navigating to the application, I was welcomed with the "Select your nationality" page (`https://www.target.com/en/select-nationality`). The page content itself is not interesting as it just asks the user to select the nationality which will then redirects to the login page.

A quick fuzzing for parameters using Arjun reveals a parameter called `returnUrl`. Appending the parameter to the URL with basic value like `https://wallet.target.com` would redirect the users to `wallet.target.com`. Naturally, I tried the next payload with `?returnUrl=https://evil.com` and it was redirected to `evil.com`. I now have an Open Redirect gadget. Why do I call it a gadget instead of a vulnerability, Open Redirect is usually treated as a low severity bug due to it's lack of impact and no impact-less $$$$, however, if you can somehow chain this Open Redirect with other vulnerabilities that you would later find, that low severity bug could be increased to high or critical depending on how you chained the gadget.

### Testing for XSS
Now, that I have an Open Redirect gadget, the most common technique to escalate the impact is by coverting this Open Redirect to a XSS. There are three-types of XSS, Reflected-XSS, Stored-XSS and DOM-based XSS. Here, we will focus on DOM-based XSS. Dom-XSS is a type of cross-site scripting vulnerability where untrusted user input is processed entirely on the client side by JavaScript and written into the DOM without proper sanitization, resulting in execution of malicious scripts in the victim’s browser. Unlike reflected or stored XSS, the malicious payload never reaches the server and is handled only by client-side code. 

The context of the user supplied input is in the URL so in this case, payloads like `<script>alert(document.domain)</script>` will not work, so we would need another way to pass our JavaScript payload in the URL. To do that, we can use the commonly used `javascript:` schema. `javascript:` is a URI scheme that tells the browser to execute JavaScript code instead of navigating to a web page. Simply crafting the payload like `javascript:alert(document.domain)` and pass it to the application, which will then renders the supplied JavaScript without any output encodings and ending-up running the attacker-supplied JavaScript code inside the application's context. Great!!! It's not every day we can find easy XSS like this without having to bypass any defense mechanisms.

Why does this happen? How does it look on the client-side code that would allow this to happen? Inspecting the JavaScript of the vulnerable page reveals the part of code that I already expected. The code is something like the following:
```
<script>
  ....
  ...
  // Get query string parameters
  const params = new URLSearchParams(window.location.search);

  // Read the returnUrl parameter
  const returnUrl = params.get("returnUrl");

  // Redirect if returnUrl exists
  if (returnUrl) {
    window.location = returnUrl;
  }
  ....
  ...
</script>
```
If you have every crossed path with JavaScript, I'm sure you'd already noticed what the issue is. The code extracts the `returnUrl` parameter from the page’s URL query string and, if present, automatically redirects the user’s browser to that value using `window.location`. Because the parameter is used directly without any validation or sanitization, the redirection target is fully controlled by user input. Hence, the Open Redirect and XSS that we have found.

### Chaining the XSS to further escalate the impact
One thing I have not yet mentioned above, in order for the Open Redirect or XSS to trigger, the victims would have to click on "Continue" button at the bottom of the page. Also, if the victims are authenticated, navigating to the vulnerable page will immediately redirect them to `/dashboard`. So, our exploitation surface is a bit limited as we can only exploit unauthenticated users and the payload triggers on one-click. Well, at least it's not a Self-XSS :). So, stealing victim's session cookies is totally out of the page and even if it was possible, the session cookie is set to HTTPOnly. At this point, I'd decided to submit the vulnerability as is and gets marked as P4 or even worst, Informative.

After taking a couple hours break, scrolling through X, I came across an article of another researcher that explains how he escalated his self-xss to critical severity. The method used was cookie tossing.

